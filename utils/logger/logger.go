// Package logger is used to write log.
// It support writing file and writing console with prefix(mean:data, time, file-name, line-number) or not.
// If set writing file, the file can roll by data and size.
//
// A example is:
//
// package main
//
// import (
//   "fmt"

//   "cloutropy.com/modules/logger"
// )

// func main() {
//   //new a instance log1. output log to file and console.
//   log1, _ := logger.NewLogger(&logger.LoggerConf{
//      LogLevel:        "ALL",
//     Dir:             "/home/admin/logs",
//     Filename:        "runlog.log",
//     ConsoleAppender: true,
//     DailyRolling:    true,
//     SizeRolling:     true,
//     MaxFileSize:     1 * logger.GB,
//     MaxFileCount:    7,
//     Withprefix:      true,
//     LogFlag:         logger.LstdFlags | logger.Lshortfile,
//   })

//  //new a instance log2. just out log to file.
//   log2, _ := logger.NewLogger(&logger.LoggerConf{
//     Dir:             "/home/admin/logs",
//     Filename:        "monitor.log",
//     DailyRolling:    true,
//     SizeRolling:     true,
//     MaxFileSize:     200 * logger.MB,
//     MaxFileCount:    7,
//   })

//  //new a instance log3. just output log to console.
//  log3, _ := logger.NewLogger(&logger.LoggerConf{
//     LogLevel:        "ALL",
//     ConsoleAppender: true,
//     Withprefix:      true,
//  })

//   log1.Debug("1 DebugDebugDebugDebugDebugDebugDebugDebugDebugDebug")
//   log1.Info("2 InfoInfoInfoInfoInfoInfoInfoInfoInfoInfoInfoInfoInfo")
//   log1.Warn("3 WarnWarnWarnWarnWarnWarnWarnWarnWarnWarnWarnWarnWarn")
//   log1.Error("4 ErrorErrorErrorErrorErrorErrorErrorErrorErrorError")
//   log1.Fatal("5 FatalFatalFatalFatalFatalFatalFatalFatalFatalFatal")

//   log2.Log("LogLogLogLogLogLogLogLogLogLogLogLogLogLogLogLogLogLog")

//   log3.Debug("6 DebugDebugDebugDebugDebugDebugDebugDebugDebugDebug")
//   log3.Info("7 InfoInfoInfoInfoInfoInfoInfoInfoInfoInfoInfoInfoInfo")
//   log3.Warn("8 WarnWarnWarnWarnWarnWarnWarnWarnWarnWarnWarnWarnWarn")
//   log3.Error("9 ErrorErrorErrorErrorErrorErrorErrorErrorErrorError")
//   log3.Fatal("10 FatalFatalFatalFatalFatalFatalFatalFatalFatalFatal")
// }

package logger

import (
  "fmt"
  "io"
  "io/ioutil"
  "os"
  "runtime"
  "strings"
  "sync"
  "time"

  "github.com/pkg/errors"
)

type LEVEL int32

const (
  ALL LEVEL = iota
  DEBUG
  INFO
  WARN
  ERROR
  FATAL
  OFF
)

const (
  KB = int64(1024)
  MB = 1024 * KB
  GB = 1024 * MB
  TB = 1024 * GB
)

const (
  TIMEFORMAT = "2006-01-02-15:04:05"
  DATEFORMAT = "2006-01-02"
  CALLDEPTH  = 2
)

type _FILE struct {
  dir      string
  filename string
  mu       *sync.RWMutex
  logfile  *os.File
  flag     int       // properties
  out      io.Writer // destination for output
  // buf      []byte     // for accumulating text to write
}

type Logger struct {
  logLevel        LEVEL
  maxFileSize     int64
  maxFileCount    int32
  dailyRolling    bool
  sizeRolling     bool
  consoleAppender bool
  fileAppender    bool
  withPrefix      bool
  logObj          *_FILE
  addCallDepth    int
}

// These flags define which text to prefix to each log entry generated by the Logger.
const (
  // Bits or'ed together to control what's printed.
  // There is no control over the order they appear (the order listed
  // here) or the format they present (as described in the comments).
  // The prefix is followed by a colon only when Llongfile or Lshortfile
  // is specified.
  // For example, flags Ldate | Ltime (or LstdFlags) produce,
  //  2009/01/23 01:23:23 message
  // while flags Ldate | Ltime | Lmicroseconds | Llongfile produce,
  //  2009/01/23 01:23:23.123123 /a/b/c/d.go:23: message
  Ldate         = 1 << iota     // the date in the local time zone: 2009/01/23
  Ltime                         // the time in the local time zone: 01:23:23
  Lmicroseconds                 // microsecond resolution: 01:23:23.123123.  assumes Ltime.
  Llongfile                     // full file name and line number: /a/b/c/d.go:23
  Lshortfile                    // final file name element and line number: d.go:23. overrides Llongfile
  LUTC                          // if Ldate or Ltime is set, use UTC rather than the local time zone
  LstdFlags     = Ldate | Ltime // initial values for the standard logger
)

type LoggerConf struct {
  // All log level form low to high :ALL,DEBUG,INFO,WARN,ERROR,FATAL,OFF.
  // default is ALL.
  LogLevel string

  // the dir of log file.
  Dir string

  // the name of log file.
  // if both Dir and Filename are not null, file will be write;
  // if both Dir and Filename are null, file will not be write;
  // else will be error.
  Filename string

  // log whether appender to console. default false.
  ConsoleAppender bool

  // log file whether rolling by daily. default false.
  DailyRolling bool

  // log file whether rolling by size. default false.
  SizeRolling bool

  // if SizeRolling is true, the max file size to roll. can use KB,MB,TB. default 0.
  MaxFileSize int64

  // if log file is rolling, max the sum of log files. default 0.
  MaxFileCount int32

  //The prefix appears at the beginning of each generated log line.
  //The flag argument defines the logging properties.
  Withprefix bool

  LogFlag int

  AddCallDepth int
}

func NewLogger(conf *LoggerConf) (*Logger, error) {
  logg := &Logger{}

  logg.setLogLevel(conf.LogLevel)

  logg.consoleAppender = conf.ConsoleAppender
  logg.withPrefix = conf.Withprefix
  logg.fileAppender = true
  if conf.Dir == "" && conf.Filename == "" {
    logg.fileAppender = false
    return logg, nil
  }
  if conf.Dir == "" || conf.Filename == "" {
    return nil, errors.New("dir and filename are not null.")
  }

  logg.maxFileCount = conf.MaxFileCount
  logg.dailyRolling = conf.DailyRolling
  logg.sizeRolling = conf.SizeRolling
  logg.maxFileSize = conf.MaxFileSize

  if logg.sizeRolling && logg.maxFileSize <= 0 {
    logg.maxFileSize = 1 * GB //default maxFileSize is 1GB.
  }

  if logg.maxFileCount <= 0 {
    logg.maxFileCount = 7 // default maxFileCount is 7.
  }

  logg.logObj = &_FILE{
    dir:      conf.Dir,
    filename: conf.Filename,
    mu:       new(sync.RWMutex),
    flag:     conf.LogFlag,
  }
  // when DEBUG: as detailed as possible
  // if logg.logLevel <= DEBUG {
  //   logg.logObj.flag = Lmicroseconds | LstdFlags | Llongfile
  // }
  logg.addCallDepth = conf.AddCallDepth

  if err := logg.createFile(false); err != nil {
    return nil, errors.WithStack(err)
  }
  if logg.dailyRolling || logg.sizeRolling {
    go logg.fileCheck()
  }

  return logg, nil
}

func (l *Logger) setLogLevel(_level string) {
  switch _level {
  case "ALL":
    l.logLevel = 0
  case "DEBUG":
    l.logLevel = 1
  case "INFO":
    l.logLevel = 2
  case "WARN":
    l.logLevel = 3
  case "ERROR":
    l.logLevel = 4
  case "FATAL":
    l.logLevel = 5
  case "OFF":
    l.logLevel = 6
  default:
    l.logLevel = 2
  }
}

func catchError() {
  if err := recover(); err != nil {
    fmt.Println("err", err)
  }
}

func (l *Logger) fileCheck() {
  timerTask := time.Tick(time.Second)

  for {
    select {
    case now := <-timerTask:
      rename := false
      file, err := l.logObj.logfile.Stat()

      if file == nil || err != nil && os.IsNotExist(err) {
        l.createFile(false)
        continue
      }

      if l.sizeRolling {
        if file.Size() >= l.maxFileSize {
          rename = true
        }
      }

      if !rename && l.dailyRolling {
        nowDate, _ := time.Parse(DATEFORMAT, now.Format(DATEFORMAT))
        nextDate, _ := time.Parse(DATEFORMAT, now.Add(time.Second).Format(DATEFORMAT))
        if nowDate.Before(nextDate) {
          rename = true
        }
      }

      if rename {
        err1 := l.createFile(true)
        err2 := l.deleteFile()

        if err1 != nil {
          l.Error(err1.Error())
        }
        if err2 != nil {
          l.Error(err2.Error())
        }
      }
    }
  }
}

func mkdirlog(dir string) error {
  _, err := os.Stat(dir)
  b := err == nil || os.IsExist(err)
  if b {
    return nil
  }
  err = os.MkdirAll(dir, 0776)
  return err
}

func (l *Logger) createFile(needRename bool) error {
  defer catchError()
  var err error
  obj := l.logObj

  if err = mkdirlog(obj.dir); err != nil {
    return err
  }

  if needRename {
    fn := obj.dir + "/" + obj.filename + "." + time.Now().Format(TIMEFORMAT)
    if err = os.Rename(obj.dir+"/"+obj.filename, fn); err != nil {
      l.Error(obj.filename, " rename error: ", err.Error())
    }
  }

  var nextLogfile *os.File
  if nextLogfile, err = os.OpenFile(obj.dir+"/"+obj.filename, os.O_RDWR|os.O_APPEND|os.O_CREATE, 0666); err != nil {
    l.Error("create file error. filename: ", obj.filename)
    return err
  }

  if obj.logfile != nil {
    obj.mu.Lock()
    defer obj.mu.Unlock()
    obj.logfile.Close()
  }

  obj.out = nextLogfile
  obj.logfile = nextLogfile

  return nil
}

func (l *Logger) deleteFile() error {
  defer catchError()
  dirList, err := ioutil.ReadDir(l.logObj.dir)
  if err != nil {
    return err
  }
  hadFile := int32(0)
  for i := len(dirList) - 1; i >= 0; i-- {
    if strings.Index(dirList[i].Name(), l.logObj.filename+".") == 0 && !dirList[i].IsDir() {
      hadFile++
      //fmt.Println(dirList[i].Name(), hadFile)
      if hadFile > l.maxFileCount {
        if err = os.Remove(l.logObj.dir + "/" + dirList[i].Name()); err != nil {
          l.Error("remove file error. fileName:", dirList[i].Name(), ". error: ", err.Error())
          return err
        }
      }
    }
  }
  return nil
}

// Cheap integer to fixed-width decimal ASCII.  Give a negative width to avoid zero-padding.
func itoa(buf *[]byte, i int, wid int) {
  // Assemble decimal in reverse order.
  var b [20]byte
  bp := len(b) - 1
  for i >= 10 || wid > 1 {
    wid--
    q := i / 10
    b[bp] = byte('0' + i - q*10)
    bp--
    i = q
  }
  // i < 10
  b[bp] = byte('0' + i)
  *buf = append(*buf, b[bp:]...)
}

func (l *Logger) formatHeader(buf *[]byte, t time.Time, file string, line int) {
  if l.logObj.flag&LUTC != 0 {
    t = t.UTC()
  }
  if l.logObj.flag&(Ldate|Ltime|Lmicroseconds) != 0 {
    if l.logObj.flag&Ldate != 0 {
      year, month, day := t.Date()
      itoa(buf, year, 4)
      *buf = append(*buf, '/')
      itoa(buf, int(month), 2)
      *buf = append(*buf, '/')
      itoa(buf, day, 2)
      *buf = append(*buf, ' ')
    }
    if l.logObj.flag&(Ltime|Lmicroseconds) != 0 {
      hour, min, sec := t.Clock()
      itoa(buf, hour, 2)
      *buf = append(*buf, ':')
      itoa(buf, min, 2)
      *buf = append(*buf, ':')
      itoa(buf, sec, 2)
      if l.logObj.flag&Lmicroseconds != 0 {
        *buf = append(*buf, '.')
        itoa(buf, t.Nanosecond()/1e3, 6)
      }
      *buf = append(*buf, ' ')
    }
  }
  if l.logObj.flag&(Lshortfile|Llongfile) != 0 {
    if l.logObj.flag&Lshortfile != 0 {
      short := file
      for i := len(file) - 1; i > 0; i-- {
        if file[i] == '/' {
          short = file[i+1:]
          break
        }
      }
      file = short
    }
    *buf = append(*buf, file...)
    *buf = append(*buf, ':')
    itoa(buf, line, -1)
    *buf = append(*buf, ": "...)
  }
}

// func (l *Logger) Output(calldepth int, prefix, s string) error {
//   now := time.Now() // get this early.
//   var file string
//   var line int
//   l.logObj.mu.Lock()
//   defer l.logObj.mu.Unlock()
//   if l.logObj.flag&(Lshortfile|Llongfile) != 0 {
//     // release lock while getting caller info - it's expensive.
//     l.logObj.mu.Unlock()
//     var ok bool
//     _, file, line, ok = runtime.Caller(calldepth)
//     if !ok {
//       file = "???"
//       line = 0
//     }
//     l.logObj.mu.Lock()
//   }
//   l.logObj.buf = l.logObj.buf[:0]
//   l.logObj.buf = append(l.logObj.buf, prefix...)
//   l.logObj.buf = append(l.logObj.buf, ' ')
//   l.formatHeader(&l.logObj.buf, now, file, line)
//   l.logObj.buf = append(l.logObj.buf, s...)
//   if len(s) == 0 || s[len(s)-1] != '\n' {
//     l.logObj.buf = append(l.logObj.buf, '\n')
//   }
//   _, err := l.logObj.out.Write(l.logObj.buf)
//   if l.consoleAppender {
//     fmt.Printf("%s", l.logObj.buf)
//   }
//   return err
// }

/*
 如果output调用过多，buf过多，大于文件写入速度，可能造成内存溢出！
*/
func (l *Logger) output(prefix, s string) error {
  now := time.Now() // get this early.
  var file string
  var line int
  if l.logObj.flag&(Lshortfile|Llongfile) != 0 {
    var ok bool
    _, file, line, ok = runtime.Caller(CALLDEPTH + l.addCallDepth)
    if !ok {
      file = "???"
      line = 0
    }
  }
  var buf []byte
  if l.withPrefix {
    buf = append(buf, prefix...)
    buf = append(buf, ' ')
    l.formatHeader(&buf, now, file, line)
  }
  buf = append(buf, s...)
  if len(s) == 0 || s[len(s)-1] != '\n' {
    buf = append(buf, '\n')
  }

  var err error
  if l.fileAppender && l.logObj != nil {
    l.logObj.mu.Lock()
    if l.logObj != nil {
      _, err = l.logObj.out.Write(buf)
    }
    l.logObj.mu.Unlock()
  }

  if l.consoleAppender {
    fmt.Printf("%s", buf)
  }

  return err
}

/*
 import "github.com/pkg/errors"
 */
func (l *Logger) sprintln(v ...interface{}) string {
  if l.logLevel <= DEBUG {
    if len(v) == 0 {
      return ""
    }
    var format = "%+v"
    for i := 1; i < len(v); i++ {
      format += " %+v"
    }
    return fmt.Sprintf(format, v...)
  } else {
    return fmt.Sprintln(v...)
  }
}

func (l *Logger) sprintf(format string, v ...interface{}) string {
  if l.logLevel <= DEBUG {
    format = strings.Replace(format, "%v", "%+v", -1)
  }
  return fmt.Sprintf(format, v...)
}

func (l *Logger) Debug(v ...interface{}) {
  if l.logLevel > DEBUG {
    return
  }
  // defer catchError()
  l.output("[D]", l.sprintln(v...))
}

func (l *Logger) Info(v ...interface{}) {
  if l.logLevel > INFO {
    return
  }
  l.output("[I]", l.sprintln(v...))
}

func (l *Logger) Warn(v ...interface{}) {
  if l.logLevel > WARN {
    return
  }
  l.output("[W]", l.sprintln(v...))
}

func (l *Logger) Error(v ...interface{}) {
  if l.logLevel > ERROR {
    return
  }
  l.output("[E]", l.sprintln(v...))
}

func (l *Logger) Fatal(v ...interface{}) {
  l.output("[F]", l.sprintln(v...))
  os.Exit(1)
}

func (l *Logger) Fatalf(format string, v ...interface{}) {
  l.output("[F]", l.sprintf(format, v...))
  os.Exit(1)
}

func (l *Logger) Fatalln(v ...interface{}) {
  l.output("[F]", l.sprintln(v...))
  os.Exit(1)
}

func (l *Logger) Println(v ...interface{}) {
  l.output("[I]", l.sprintln(v...))
}

func (l *Logger) Printf(format string, v ...interface{}) {
  l.output("[I]", l.sprintf(format, v...))
}

func (l *Logger) Print(v ...interface{}) {
  l.output("[I]", l.sprintln(v...))
}

func (l *Logger) Panic(v ...interface{}) {
  s := l.sprintln(v...)
  l.output("[F]", s)
  panic(s)
}

func (l *Logger) Panicf(format string, v ...interface{}) {
  s := l.sprintf(format, v...)
  l.output("[F]", s)
  panic(s)
}

func (l *Logger) Panicln(v ...interface{}) {
  s := l.sprintln(v...)
  l.output("[F]", s)
  panic(s)
}


var std *Logger
func init() {
  var err error
  std, err = NewLogger(&LoggerConf{
    LogLevel: "ALL",
    Dir: ".",
    Filename: "server.log",
    ConsoleAppender: true,
    SizeRolling: true,
    MaxFileCount: 7,
    MaxFileSize: 100 * MB,
    Withprefix: true,
    LogFlag: LstdFlags | Lshortfile,
  })
  if err != nil {
    fmt.Println("logger init fail.")
    os.Exit(1)
  }
}

func InitLogger(conf *LoggerConf) error {
  var err error
  std, err = NewLogger(conf)
  return err
}

func Debug(v ...interface{}) {
  if std.logLevel > DEBUG {
    return
  }
  // defer catchError()
  std.output("[D]", std.sprintln(v...))
}

func Info(v ...interface{}) {
  if std.logLevel > INFO {
    return
  }
  std.output("[I]", std.sprintln(v...))
}

func Warn(v ...interface{}) {
  if std.logLevel > WARN {
    return
  }
  std.output("[W]", std.sprintln(v...))
}

func Error(v ...interface{}) {
  if std.logLevel > ERROR {
    return
  }
  std.output("[E]", std.sprintln(v...))
}

func Fatal(v ...interface{}) {
  std.output("[F]", std.sprintln(v...))
  os.Exit(1)
}

func Fatalf(format string, v ...interface{}) {
  std.output("[F]", std.sprintf(format, v...))
  os.Exit(1)
}

func Fatalln(v ...interface{}) {
  std.output("[F]", std.sprintln(v...))
  os.Exit(1)
}

func Println(v ...interface{}) {
  std.output("[I]", std.sprintln(v...))
}

func Printf(format string, v ...interface{}) {
  std.output("[I]", std.sprintf(format, v...))
}

func Print(v ...interface{}) {
  std.output("[I]", std.sprintln(v...))
}

func Panic(v ...interface{}) {
  s := std.sprintln(v...)
  std.output("[F]", s)
  panic(s)
}

func Panicf(format string, v ...interface{}) {
  s := std.sprintf(format, v...)
  std.output("[F]", s)
  panic(s)
}

func Panicln(v ...interface{}) {
  s := std.sprintln(v...)
  std.output("[F]", s)
  panic(s)
}
